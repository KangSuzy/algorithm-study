## 2주차 공통문제
### [백준 1439 뒤집기](https://www.acmicpc.net/problem/1439)
- 문제 유형: 문자열, 그리디
- 시간 복잡도: O(N)
- 공간 복잡도: O(1)
- 접근 방법
    - 처음엔 문자열에 속한 0과 1의 개수를 세서 더 적은 것을 바꾸면 되겠다고 생각했다.
    - 하지만 테스트를 해보니 개수가 중요한 것이 아니라 0과 1의 그룹(= 연속되는 숫자)개수가 중요한 것이었다!
    - 문자열을 돌면서 0과 1의 그룹 개수를 구한 후 작은 값을 리턴하면 된다.
<br/><br/>
- 풀이
    1. 0과 1의 그룹 개수를 저장하는 zero, one과 탐색하고 있던 숫자를 저장할 num을 생성한다.
    2. S의 문자를 하나씩 탐색한다.
        - 현재 숫자와 탐색하고 있던 숫자가 달라지는 경우, 현재 숫자에 따른 개수에 +1, 탐색하고 있던 숫자를 변경한다.
        - 예를 들어, '0011'의 경우 현재 숫자('1') != 탐색하고 있던 숫자('0')가 되면 현재 숫자가 1이므로 one에 +1을 하고, 탐색하고 있던 숫자를 '1'로 바꾼다.
    3. 탐색이 끝나면 0과 1의 그룹 개수 중 작은 것을 출력한다.
<br/><br/>
- 코드
```python
S = input()
num = '' # 탐색하고 있던 숫자
zero, one = 0, 0

for s in S:
    if s != num: # 현재 숫자와 탐색하고 있던 숫자가 달라지면 개수에 +1, 탐색하고 있던 숫자를 변경
        if s == '0':
            zero += 1
        else:
            one += 1
        num = s
print(min(zero, one))
```

### [백준 5525 IOIOI](https://www.acmicpc.net/problem/5525)
- 문제 유형: 문자열
- 시간 복잡도: O(N)
- 공간 복잡도: O(1)
- 접근 방법
    - N에 따른 반복되는 문자열(P)을 구하고 S를 탐색하면서 인덱싱한 것과 P를 비교하여 답을 구했다.
    - 이렇게 했더니 답은 맞았지만 시간초과가 발생해서 50점이 나왔다.
    - 문자열을 도는 반복문 O(N) * 문자열 인덱싱 O(N) = O(N^2) 으로 시간초과가 난 것 같다.
    - 시간초과를 해결하기 위해서는 반복문을 한 번만 돌아 O(N)을 만들어야 했다.
    - 근데 어떻게 해야할지 모르겠어서 풀이를 찾아보았다.
<br/><br/>
- 풀이
    1. 반복 횟수를 저장하는 count를 생성한다.
    2. 문자열 S를 탐색한다.
    3. P의 패턴과 같다면 반복횟수에 +1을 한다.
        - 이 때, 반복횟수 = N 이라면 count에 -1, answer에 +1을 한다. P가 다음에 또 반복될 수 있므로 초기화하는 것이 아니라 -1을 해주는 것!
        - 현재 패턴이 'IOI' 이므로 어차피 다음 문자에서는 패턴이 'OIO'가 된다. 따라서 볼 필요가 없으므로 다음 문자로 넘어갈 수 있도록 i에 +1을 한다.
    4. P의 패턴과 다르다면 count를 초기화한다.
    5. 모든 탐색이 끝나면 결과를 출력한다.
<br/><br/>
- 코드
```python
N = int(input())
M = int(input())
S = input()
count = 0 # 반복 횟수
answer = 0
i = 1

while i < M-1:
    if S[i-1] == 'I' and S[i] == 'O' and S[i+1] == 'I': # P의 패턴과 같다면
        count += 1 # 반복 횟수에 +1
        if count == N: # 반복횟수와 N이 같은 경우 P가 포함되어 있는 것이므로 answer에 +1
            count -= 1 # P가 다음에 또 반복될 수 있으므로 count에 -1을 한다 (초기화 X)
            answer += 1
        i += 1 # 다음 문자에서는 어차피 패턴이 'OIO'가 되므로 볼 필요가 없으니까 i에 +1
    else: # P의 패턴과 다르다면 count 초기화
        count = 0
    i += 1
print(answer)
```

### [백준 9935 문자열 폭발](https://www.acmicpc.net/problem/9935)
- 문제 유형: 문자열, 스택
- 시간 복잡도: O(N^2)
- 공간 복잡도: O(N)
- 접근 방법
    - 먼저 replace를 사용하여 폭발할 문자열을 제거한 후, 폭발할 문자열이 문자열에 없다면 반복문을 빠져나오도록 했다. -> 시간초과
    - 찾아보니 스택을 사용해야 시간초과를 해결할 수 있다는 것을 알게 되었다.
<br/><br/>
- 풀이
    1. 폭발이 끝나고 남은 문자열을 저장할 answer 리스트를 생성한다.
    2. 문자열을 탐색한다.
        - 현재 문자를 answer에 삽입한다.
        - 폭발할 문자열과 같다면 삭제한다.
    3. 탐색이 끝난 후, 케이스에 따른 결과를 출력한다.
<br/><br/>
- 코드
```python
s = input()
exp = input()
l = len(exp)
answer = []

for c in s:
    answer.append(c)
    if c == exp[-1] and ''.join(answer[-l:]) == exp: # 폭발할 문자열과 같으면 삭제
        del answer[-l:]

if answer:
    print(''.join(answer))
else:
    print('FRULA')
```